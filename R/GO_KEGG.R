

#' GO analysis for human gene symbols; human only!
#'
#' @param DEG.genes gene symbols of DEGs
#' @param background.genes background gene symbols ,default not provide
#'
#' @return a list consists of GO result objects, inculuding all, BP, MF, CC
#' @export
#'
#' @examples my_GO(deg.sig)
my_GO <- function(DEG.genes, background.genes){

    ## gene symobl to entrnzID
    df <- bitr(geneID = unique(DEG.genes),
               fromType = "SYMBOL",
               toType = c( "ENTREZID"),
               OrgDb = org.Hs.eg.db)
    gene = df[['ENTREZID']]

    ## GO analysis
    if(missing(background.genes)){

        ## defalut, background genes not provided
        go_enrich_results <- lapply( c('all','BP','MF','CC') , function(ont) {
            cat(paste('Now process', ont, '\n', collapse = ''))
            ego <- enrichGO(gene          = gene,
                            OrgDb         = org.Hs.eg.db,
                            ont           = ont ,
                            pAdjustMethod = "BH",
                            pvalueCutoff  = 0.9,
                            qvalueCutoff  = 0.9,
                            readable      = TRUE)
            return(ego)
        })

    }else{

        ## background genes provided
        df_bg <- bitr(geneID = unique(background.genes),
                   fromType = "SYMBOL",
                   toType = c( "ENTREZID"),
                   OrgDb = org.Hs.eg.db)

        genes_background = df_bg[['ENTREZID']]

        go_enrich_results <- lapply( c('all', 'BP','MF','CC') , function(ont) {
            cat(paste('Now process', ont, '\n', collapse = ''))
            ego <- enrichGO(gene          = gene,
                            universe      = genes_background ,
                            OrgDb         = org.Hs.eg.db,
                            ont           = ont ,
                            pAdjustMethod = "BH",
                            pvalueCutoff  = 0.9,
                            qvalueCutoff  = 0.9,
                            readable      = TRUE)
            return(ego)
        })
    }

    return(go_enrich_results)

}






#' KEGG analysis for human gene symbols; human only!
#'
#' @param DEG.genes gene symbols of DEGs
#'
#' @return kegg result object
#' @export
#'
#' @examples my_kegg(deg)
my_kegg <- function(DEG.genes){

    ## gene symobl to entrnzID
    df <- bitr(geneID = unique(DEG.genes),
               fromType = "SYMBOL",
               toType = c( "ENTREZID"),
               OrgDb = org.Hs.eg.db)
    gene = df[['ENTREZID']]

    ## KEGG analysis
    kegg_result <- enrichKEGG(gene = gene,
                        organism = 'hsa',
                        keyType = 'kegg',
                        pvalueCutoff = 0.9,
                        pAdjustMethod = "BH")


    return(kegg_result)
}






#' barplot (ordered by count/ratio) and group by category of ontology (all,BP, MF, CC) all list[[1]], BP list[[2]], MF list[[3]], CC list[[4]]
#'
#' @param GO.res GO result object  generated from my_GO() function including (all,BP, MF, CC)
#' @param top number of top pathways picked, default 20
#' @param y_value ordered by count or ratio, default "count", if need ratio, use  y_value = 'ratio'
#' @param color.text if using colored labels, (go terms generated by geom_text, better give y.limit value) / if not show go terms on axis text
#' @param lab.size text size of colored labels, default 4
#' @param y.limit a vector with 2 numbers as the ymin and ymax: e.g y.limit = c(-30, 40), if not using default value
#' @param pal color palette represent for BP, MF, CC  GO category;default in 'lanonc' pal
#' @param bar.width bar width ,default 0.6
#' @param title plot title ,default NULL
#' @param xlab plot title ,default NULL
#' @param ylab plot title ,default count / ratio
#' @param base.size base text size, default 15
#' @param legend.size base legend size, default 10
#' @param legend.position legend positon, default top
#' @param cord.flip if flip the plot default F
#'
#' @return a sorted ggplot bar plot grouped by GO terms grouped by BP,MF,CC top ones
#' @export
#'
#' @examples GO_barplot_catergroy(GO.res = GOResults_list[[1]], color.text = T, y.limit = c(-30, 45))
#'
GO_barplot_catergroy <- function(GO.res, top=20, y_value="count",
                                 color.text=F, lab.size = 4, y.limit,
                                 pal=ggsci::pal_lancet(palette = c("lanonc"), alpha = 0.6)(9),
                                 bar.width = 0.6, title =NULL, xlab =NULL, ylab = "Gene counts",
                                 base.size =15, legend.size=10, legend.position = 'top',
                                 cord.flip=F){

    data = GO.res[[1]]@result %>% as.data.frame()

    if(y_value == "count"){

        data = data %>% arrange(desc(Count), pvalue) %>% head(top) %>%
            mutate(ONTOLOGY = factor(ONTOLOGY, levels=c("BP", "MF", "CC")) ) %>%
            as.data.frame()

        # arrange by count use top ones
        plot_data = data %>%
            arrange(ONTOLOGY, desc(Count)) %>%
            mutate(Description = factor(.$Description, levels = .$Description) )  %>%
            dplyr::rename(y = Count)  %>%
            as.data.frame()

    }else if(y_value == "ratio"){
        # calculate the gene ratio
        data$bg_count = stringr::str_split(data$GeneRatio, pattern = '/', simplify = T)[,2] %>% as.numeric()

        data = data %>% mutate(ratio = as.numeric(Count/bg_count)*100) %>%
            arrange(desc(ratio), pvalue) %>% head(top) %>%
            mutate(ONTOLOGY = factor(ONTOLOGY, levels=c("BP", "MF", "CC")) ) %>%
            as.data.frame()

        # arrange by ratio use top ones
        plot_data = data %>%
            arrange(ONTOLOGY, desc(ratio)) %>%
            mutate(Description = factor(.$Description, levels = .$Description) )  %>%
            dplyr::rename(y = ratio)  %>%
            as.data.frame()

        ylab = 'Gene ratio (%)'

    }else{
        stop('the y_value can only be count or ratio !!')
    }


    #  setting color for category
    category_colors <- c('BP'=pal[1], 'MF'=pal[2], 'CC'= pal[3])


    # setting Y axis limits (for color go term annotations)
    if(color.text==T & missing(y.limit)){
        ymin = -30
        ymax = max(plot_data$y) + 1
    }else if(color.text==F){
        cat('default y limits\n')
    }else{
        cat('y.limit need a vector with 2 numbers as the ymin and ymax: e.g y.limit = c(-30, 40)')
        ymin = y.limit[1]
        ymax = y.limit[2]
    }

    ## plotting
    p = ggplot(plot_data, mapping = aes(x = reorder(Description, order(ONTOLOGY, y, decreasing = c(FALSE, TRUE))), # works only data previously arranged
                                        y = y)) +
        geom_bar(aes(fill= ONTOLOGY), stat = "identity", colour = 'black', position="dodge", width = bar.width) +
        scale_fill_manual(values = category_colors )

    # title
    p = p + ggtitle(title) +  xlab(xlab) +  ylab(ylab)

    # adding text as x lab
    if(color.text==T){

        p = p +  scale_y_continuous(limits=c(ymin, ymax))

        if(cord.flip==T){
            p = p + coord_flip() +
                geom_text(aes(label = Description, color = ONTOLOGY, y = -0.5), vjust = 0.5, hjust = 1,  size = lab.size, angle = 0,
                          # position = position_dodge(width = bar.width)
                          show.legend = F) +
                scale_color_manual(values = category_colors)

            # theme
            p = p + theme_classic(base_size = base.size) + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.line.y = element_blank(),
                                                                 axis.ticks.x = element_blank(),
                                                                 legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))

        }else{
            p = p +  geom_text(aes(label = Description, color = ONTOLOGY, y = -0.5), vjust = 0.5, hjust = 1,  size = lab.size, angle = 90,
                               # position = position_dodge(width = bar.width)
                               show.legend = F) +
                scale_color_manual(values = category_colors)

            # theme
            p = p + theme_classic(base_size = base.size) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.line.x = element_blank(),
                                                                 axis.ticks.y = element_blank(),
                                                                 legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))
        }


    }else{

        if(cord.flip==T){
            p = p + coord_flip() +
                theme_classic(base_size = base.size) + theme(axis.text.x = element_text(colour = 'black', angle = 0, vjust = 0.5, hjust = 0.5), axis.ticks.x = element_blank(),
                                                             axis.ticks.y = element_blank(),
                                                             legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))
        }else{
            # if no color lab needed use default x axis instead
            p = p + theme_classic(base_size = base.size) + theme(axis.text.x = element_text(colour = 'black', angle = 90, vjust = 0.5, hjust = 1), axis.ticks.x = element_blank(),
                                                                 axis.ticks.y = element_blank(),
                                                                 legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))
        }
    }


    return(p)
}





#' barplot (ordered by count/ratio) and group by category of ontology with facets of BP CC MF
#'
#' @param GO.res GO result object  generated from my_GO() function including (all,BP, MF, CC), the all (list[[1]]) is used
#' @param top  number of top pathways picked, default 20
#' @param y_value ordered by count or ratio, default "count", if need ratio, use  y_value = 'ratio'
#' @param y.decreasing if use decreasing order, default T
#' @param lab.position the position of the labs of GO terms; default above_bar: above the bar; or on_bar : upon the bar
#' @param lab.size the text size the labs, default 4
#' @param lab.colour the text colour the labs, default black
#' @param pal color palette represent for BP, MF, CC  GO category
#' @param title title of the plot , default NULL
#' @param ylab title of the y axis, default Gene counts
#' @param y.lab.size text size of the y labs, default 14
#' @param y.title.size text size of the y title, default 18
#' @param title.size  text size of the title, default 20
#'
#' @return a ggplot object o facet GO plot
#' @export
#'
#' @examples GO_barplot_catergroy_facet(GO.res = GO.up, top = 20, y_value = 'count', y.decreasing = T, lab.position = 'on_bar', lab.colour = 'white')
GO_barplot_catergroy_facet <- function(GO.res, top=20, y_value="count", y.decreasing = T,
                                       lab.position = 'above_bar', lab.size = 4, lab.colour = 'black',
                                       pal = c("#25A17C","#D96622","#6C73B2"),
                                       title =NULL, ylab = "Gene counts",
                                       y.lab.size =14, y.title.size=18, title.size=20){

    data = GO.res[[1]]@result

    if(y_value == "count"){

        data = data %>% arrange(desc(Count), pvalue) %>% head(top) %>% dplyr::rename(y=Count) %>% as.data.frame()


    }else if(y_value == "ratio"){
        # calculate the gene ratio
        data$bg_count = stringr::str_split(data$GeneRatio, pattern = '/', simplify = T)[,2] %>% as.numeric()

        data = data %>% mutate(ratio = as.numeric(Count/bg_count)*100) %>%
            arrange(desc(ratio), pvalue) %>% head(top) %>%
            dplyr::rename(y=ratio) %>%
            as.data.frame()


        ylab = 'Gene ratio (%)'

    }else{

        stop('the y_value can only be count or ratio !!\n')
    }

    # max y value for count or ratio
    max_y_limit = max(data$y)

    # plotting
    p = ggplot(data = data,
               aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                   y = y,
                   fill = ONTOLOGY)) +
        geom_col(data = data,
                 aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                     y = y),
                 width = 0.5,
                 position = "dodge")


    # adding color and labs
    p = p + scale_fill_manual(values = pal ) +
        ggtitle(title) +  xlab(NULL) +  ylab(ylab)

    # theme
    p = p +  theme_classic() +
        theme(axis.text.x =  element_blank(),
              axis.ticks.x = element_blank(),
              axis.text.y =  element_text(size = y.lab.size, color = 'black'),
              axis.title.y = element_text(size = y.title.size, color = 'black'),
              legend.position = "none",
              panel.border = element_blank(),
              axis.line.y  = element_line(color = "black", size = 1, lineend = "square"),
              plot.title = element_text(size = title.size, color = 'black', hjust = 0.5))

    # facet
    strip <- ggh4x::strip_themed(background_x = ggh4x::elem_list_rect(color = pal) )

    p = p + ggh4x::facet_grid2(~ONTOLOGY,
                               scales = "free_x",
                               space = "free_x",
                               strip = strip,
                               switch = "both") +
        theme(axis.line.x = element_blank(),
              strip.background = element_rect(size = 2),
              strip.text = element_text(face = "bold",
                                        size = rel(1.5)))

    # lab setting
    if(lab.position == 'above_bar'){
        p = p + scale_y_continuous(limits = c(0,  ceiling( 2*max_y_limit)),
                                   expand = c(0, 0))

        p = p + geom_text(aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                              y = y + 0.02*max_y_limit,  # GO term 位置 上调
                              label = Description),
                          size = lab.size, colour = lab.colour,
                          angle = 90,
                          hjust = 0)

    }else if(lab.position == 'on_bar'){

        p = p + geom_text(aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                              y = rep(1, nrow(data)),  # GO term 固定起始位置 y = rep(1,nrow(Data)), x不要
                              label = Description),
                          size = lab.size, colour = lab.colour,
                          angle = 90,
                          hjust = 0)

    }else{
        stop('lab.position must be above_bar or on_bar ! \n')
    }

    return(p)
}




