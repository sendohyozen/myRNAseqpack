

#' GO analysis for human gene symbols; human only!
#'
#' @param DEG.genes gene symbols of DEGs
#' @param background.genes background gene symbols ,default not provide
#'
#' @return a list consists of GO result objects, inculuding all, BP, MF, CC
#' @export
#'
#' @examples my_GO(deg.sig)
my_GO <- function(DEG.genes, background.genes){

    ## gene symobl to entrnzID
    df <- bitr(geneID = unique(DEG.genes),
               fromType = "SYMBOL",
               toType = c( "ENTREZID"),
               OrgDb = org.Hs.eg.db)
    gene = df[['ENTREZID']]

    ## GO analysis
    if(missing(background.genes)){

        ## defalut, background genes not provided
        go_enrich_results <- lapply( c('all','BP','MF','CC') , function(ont) {
            cat(paste('Now process', ont, '\n', collapse = ''))
            ego <- enrichGO(gene          = gene,
                            OrgDb         = org.Hs.eg.db,
                            ont           = ont ,
                            pAdjustMethod = "BH",
                            pvalueCutoff  = 0.9,
                            qvalueCutoff  = 0.9,
                            readable      = TRUE)
            return(ego)
        })

    }else{

        ## background genes provided
        df_bg <- bitr(geneID = unique(background.genes),
                   fromType = "SYMBOL",
                   toType = c( "ENTREZID"),
                   OrgDb = org.Hs.eg.db)

        genes_background = df_bg[['ENTREZID']]

        go_enrich_results <- lapply( c('all', 'BP','MF','CC') , function(ont) {
            cat(paste('Now process', ont, '\n', collapse = ''))
            ego <- enrichGO(gene          = gene,
                            universe      = genes_background ,
                            OrgDb         = org.Hs.eg.db,
                            ont           = ont ,
                            pAdjustMethod = "BH",
                            pvalueCutoff  = 0.9,
                            qvalueCutoff  = 0.9,
                            readable      = TRUE)
            return(ego)
        })
    }

    return(go_enrich_results)

}






#' KEGG analysis for human gene symbols; human only!
#'
#' @param DEG.genes gene symbols of DEGs
#'
#' @return kegg result object
#' @export
#'
#' @examples my_kegg(deg)
my_kegg <- function(DEG.genes){

    ## gene symobl to entrnzID
    df <- bitr(geneID = unique(DEG.genes),
               fromType = "SYMBOL",
               toType = c( "ENTREZID"),
               OrgDb = org.Hs.eg.db)
    gene = df[['ENTREZID']]

    ## KEGG analysis
    kegg_result <- enrichKEGG(gene = gene,
                        organism = 'hsa',
                        keyType = 'kegg',
                        pvalueCutoff = 0.9,
                        pAdjustMethod = "BH")


    return(kegg_result)
}






#' barplot (ordered by count/ratio) and group by category of ontology (all,BP, MF, CC) all list[[1]], BP list[[2]], MF list[[3]], CC list[[4]]
#'
#' @param GO.res GO result object  generated from my_GO() function including (all,BP, MF, CC)
#' @param top number of top pathways picked, default 20
#' @param y_value ordered by count or ratio, default "count", if need ratio, use  y_value = 'ratio'
#' @param color.text if using colored labels, (go terms generated by geom_text, better give y.limit value) / if not show go terms on axis text
#' @param lab.size text size of colored labels, default 4
#' @param y.limit a vector with 2 numbers as the ymin and ymax: e.g y.limit = c(-30, 40), if not using default value
#' @param pal color palette represent for BP, MF, CC  GO category;default in 'lanonc' pal
#' @param bar.width bar width ,default 0.6
#' @param title plot title ,default NULL
#' @param xlab plot title ,default NULL
#' @param ylab plot title ,default count / ratio
#' @param base.size base text size, default 15
#' @param legend.size base legend size, default 10
#' @param legend.position legend positon, default top
#' @param cord.flip if flip the plot default F
#'
#' @return a sorted ggplot bar plot grouped by GO terms grouped by BP,MF,CC top ones
#' @export
#'
#' @examples GO_barplot_catergroy(GO.res = GOResults_list[[1]], color.text = T, y.limit = c(-30, 45))
#'
GO_barplot_catergroy <- function(GO.res, top=20, y_value="count",
                                 color.text=F, lab.size = 4, y.limit,
                                 pal=ggsci::pal_lancet(palette = c("lanonc"), alpha = 0.6)(9),
                                 bar.width = 0.6, title =NULL, xlab =NULL, ylab = "Gene counts",
                                 base.size =15, legend.size=10, legend.position = 'top',
                                 cord.flip=F){

    data = GO.res[[1]]@result %>% as.data.frame()

    if(y_value == "count"){

        data = data %>% arrange(desc(Count), pvalue) %>% head(top) %>%
            mutate(ONTOLOGY = factor(ONTOLOGY, levels=c("BP", "MF", "CC")) ) %>%
            as.data.frame()

        # arrange by count use top ones
        plot_data = data %>%
            arrange(ONTOLOGY, desc(Count)) %>%
            mutate(Description = factor(.$Description, levels = .$Description) )  %>%
            dplyr::rename(y = Count)  %>%
            as.data.frame()

    }else if(y_value == "ratio"){
        # calculate the gene ratio
        data$bg_count = stringr::str_split(data$GeneRatio, pattern = '/', simplify = T)[,2] %>% as.numeric()

        data = data %>% mutate(ratio = as.numeric(Count/bg_count)*100) %>%
            arrange(desc(ratio), pvalue) %>% head(top) %>%
            mutate(ONTOLOGY = factor(ONTOLOGY, levels=c("BP", "MF", "CC")) ) %>%
            as.data.frame()

        # arrange by ratio use top ones
        plot_data = data %>%
            arrange(ONTOLOGY, desc(ratio)) %>%
            mutate(Description = factor(.$Description, levels = .$Description) )  %>%
            dplyr::rename(y = ratio)  %>%
            as.data.frame()

        ylab = 'Gene ratio (%)'

    }else{
        stop('the y_value can only be count or ratio !!')
    }


    #  setting color for category
    category_colors <- c('BP'=pal[1], 'MF'=pal[2], 'CC'= pal[3])


    # setting Y axis limits (for color go term annotations)
    if(color.text==T & missing(y.limit)){
        ymin = -30
        ymax = max(plot_data$y) + 1
    }else if(color.text==F){
        cat('default y limits\n')
    }else{
        cat('y.limit need a vector with 2 numbers as the ymin and ymax: e.g y.limit = c(-30, 40)')
        ymin = y.limit[1]
        ymax = y.limit[2]
    }

    ## plotting
    p = ggplot(plot_data, mapping = aes(x = reorder(Description, order(ONTOLOGY, y, decreasing = c(FALSE, TRUE))), # works only data previously arranged
                                        y = y)) +
        geom_bar(aes(fill= ONTOLOGY), stat = "identity", colour = 'black', position="dodge", width = bar.width) +
        scale_fill_manual(values = category_colors )

    # title
    p = p + ggtitle(title) +  xlab(xlab) +  ylab(ylab)

    # adding text as x lab
    if(color.text==T){

        p = p +  scale_y_continuous(limits=c(ymin, ymax))

        if(cord.flip==T){
            p = p + coord_flip() +
                geom_text(aes(label = Description, color = ONTOLOGY, y = -0.5), vjust = 0.5, hjust = 1,  size = lab.size, angle = 0,
                          # position = position_dodge(width = bar.width)
                          show.legend = F) +
                scale_color_manual(values = category_colors)

            # theme
            p = p + theme_classic(base_size = base.size) + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.line.y = element_blank(),
                                                                 axis.ticks.x = element_blank(),
                                                                 legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))

        }else{
            p = p +  geom_text(aes(label = Description, color = ONTOLOGY, y = -0.5), vjust = 0.5, hjust = 1,  size = lab.size, angle = 90,
                               # position = position_dodge(width = bar.width)
                               show.legend = F) +
                scale_color_manual(values = category_colors)

            # theme
            p = p + theme_classic(base_size = base.size) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.line.x = element_blank(),
                                                                 axis.ticks.y = element_blank(),
                                                                 legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))
        }


    }else{

        if(cord.flip==T){
            p = p + coord_flip() +
                theme_classic(base_size = base.size) + theme(axis.text.x = element_text(colour = 'black', angle = 0, vjust = 0.5, hjust = 0.5), axis.ticks.x = element_blank(),
                                                             axis.ticks.y = element_blank(),
                                                             legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))
        }else{
            # if no color lab needed use default x axis instead
            p = p + theme_classic(base_size = base.size) + theme(axis.text.x = element_text(colour = 'black', angle = 90, vjust = 0.5, hjust = 1), axis.ticks.x = element_blank(),
                                                                 axis.ticks.y = element_blank(),
                                                                 legend.position = legend.position, legend.title = element_blank(), legend.text = element_text(size = legend.size))
        }
    }


    return(p)
}





#' barplot (ordered by count/ratio) and group by category of ontology with facets of BP CC MF
#'
#' @param GO.res GO result object  generated from my_GO() function including (all,BP, MF, CC), the all (list[[1]]) is used
#' @param top  number of top pathways picked, default 20
#' @param y_value ordered by count or ratio, default "count", if need ratio, use  y_value = 'ratio'
#' @param y.decreasing if use decreasing order, default T
#' @param lab.position the position of the labs of GO terms; default above_bar: above the bar; or on_bar : upon the bar
#' @param lab.size the text size the labs, default 4
#' @param lab.colour the text colour the labs, default black
#' @param pal color palette represent for BP, MF, CC  GO category
#' @param title title of the plot , default NULL
#' @param ylab title of the y axis, default Gene counts
#' @param y.lab.size text size of the y labs, default 14
#' @param y.title.size text size of the y title, default 18
#' @param title.size  text size of the title, default 20
#'
#' @return a ggplot object o facet GO plot
#' @export
#'
#' @examples GO_barplot_catergroy_facet(GO.res = GO.up, top = 20, y_value = 'count', y.decreasing = T, lab.position = 'on_bar', lab.colour = 'white')
GO_barplot_catergroy_facet <- function(GO.res, top=20, y_value="count", y.decreasing = T,
                                       lab.position = 'above_bar', lab.size = 4, lab.colour = 'black',
                                       pal = c("#25A17C","#D96622","#6C73B2"),
                                       title =NULL, ylab = "Gene counts",
                                       y.lab.size =14, y.title.size=18, title.size=20){

    data = GO.res[[1]]@result

    if(y_value == "count"){

        data = data %>% arrange(desc(Count), pvalue) %>% head(top) %>% dplyr::rename(y=Count) %>% as.data.frame()


    }else if(y_value == "ratio"){
        # calculate the gene ratio
        data$bg_count = stringr::str_split(data$GeneRatio, pattern = '/', simplify = T)[,2] %>% as.numeric()

        data = data %>% mutate(ratio = as.numeric(Count/bg_count)*100) %>%
            arrange(desc(ratio), pvalue) %>% head(top) %>%
            dplyr::rename(y=ratio) %>%
            as.data.frame()


        ylab = 'Gene ratio (%)'

    }else{

        stop('the y_value can only be count or ratio !!\n')
    }

    # max y value for count or ratio
    max_y_limit = max(data$y)

    # plotting
    p = ggplot(data = data,
               aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                   y = y,
                   fill = ONTOLOGY)) +
        geom_col(data = data,
                 aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                     y = y),
                 width = 0.5,
                 position = "dodge")


    # adding color and labs
    p = p + scale_fill_manual(values = pal ) +
        ggtitle(title) +  xlab(NULL) +  ylab(ylab)

    # theme
    p = p +  theme_classic() +
        theme(axis.text.x =  element_blank(),
              axis.ticks.x = element_blank(),
              axis.text.y =  element_text(size = y.lab.size, color = 'black'),
              axis.title.y = element_text(size = y.title.size, color = 'black'),
              legend.position = "none",
              panel.border = element_blank(),
              axis.line.y  = element_line(color = "black", size = 1, lineend = "square"),
              plot.title = element_text(size = title.size, color = 'black', hjust = 0.5))

    # facet
    strip <- ggh4x::strip_themed(background_x = ggh4x::elem_list_rect(color = pal) )

    p = p + ggh4x::facet_grid2(~ONTOLOGY,
                               scales = "free_x",
                               space = "free_x",
                               strip = strip,
                               switch = "both") +
        theme(axis.line.x = element_blank(),
              strip.background = element_rect(size = 2),
              strip.text = element_text(face = "bold",
                                        size = rel(1.5)))

    # lab setting
    if(lab.position == 'above_bar'){
        p = p + scale_y_continuous(limits = c(0,  ceiling( 2*max_y_limit)),
                                   expand = c(0, 0))

        p = p + geom_text(aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                              y = y + 0.02*max_y_limit,  # GO term 位置 上调
                              label = Description),
                          size = lab.size, colour = lab.colour,
                          angle = 90,
                          hjust = 0)

    }else if(lab.position == 'on_bar'){

        p = p + geom_text(aes(x = forcats::fct_reorder(Description, y, .desc = y.decreasing),
                              y = rep(1, nrow(data)),  # GO term 固定起始位置 y = rep(1,nrow(Data)), x不要
                              label = Description),
                          size = lab.size, colour = lab.colour,
                          angle = 90,
                          hjust = 0)

    }else{
        stop('lab.position must be above_bar or on_bar ! \n')
    }

    return(p)
}





#' bubleplot for go,kegg analysis
#'
#' @param df dataframe of go, kegg results
#' @param x column name of x axis
#' @param y column name of y axis
#' @param size column name showing size of the buble
#' @param color column name showing  color of the buble
#' @param title title of the plot , default "KEGG"
#' @param pal color palette of the bulbe color; a vector consists of two numbers, the fisrt for low , the second for high
#'
#' @return ggplot2 object of a buble plt
#' @export
#'
#' @examples my_bublePlot(df = data, x = 'pvalue', y = 'Description', size = 'Count' , color = 'p.adjust', title = 'KEGG')
my_bublePlot = function(df, x, y, size, color,
                        title='KEGG', pal=c('blue', 'red')){

    ## plot data
    df = as.data.frame(df)
    x_value = df[[x]]
    y_value = df[[y]]
    buble_Size = df[[size]]
    buble_color = df[[color]]

    plot_df = data.frame(x_value,  y_value,  buble_Size, buble_color, stringsAsFactors=FALSE)

    ## ploting
    p = ggplot(data= plot_df, aes(x=x_value, y=y_value)) +
        geom_point(aes(size=buble_Size, color=-1*log(buble_color))) +
        scale_color_gradient(low = pal[1], high = pal[2])

    p = p + labs(color = paste0('-log10(', color,')'),
                 size = size,
                 x = x, y = y,
                 title = title) +
        theme_bw() +
        theme(axis.text.x = element_text(size=10,angle = 90, hjust = 0.5, vjust = 0.5),
              axis.text.y = element_text(color = "black",size=12),
              axis.title.x = element_text(color = "black",size=14),
              axis.title.y = element_blank())


    return(p)
}




#' matchstick_plot for go,kegg,gsea... analysis
#'
#' @param df dataframe of go, kegg,... results
#' @param top top term picked for plotting , arranged by count and pvalue , default top 20
#' @param y.decreasing if arranged the sticked with derceasing order, default T
#' @param logPV10 if use the -log10pvalue for filling colors, default T
#' @param x column name of x axis data, (the plot is coordfliped) default Description
#' @param y column name of y axis data, (the plot is coordfliped) default count
#' @param size column name of point size, default count
#' @param fill_col column name of filling color, default pvalue
#' @param fill_col_pal color palette of the bulbe color; a vector consists of two numbers, the fisrt for low , the second for high;
#' @param stick_col color of the stick
#' @param stick_width width of the stick, default 2
#' @param title title of the plot, default NULL
#' @param xlab x lab of the plot, default NULL
#' @param ylab y lab of the plot, default 'Gene Counts'
#' @param x.lab.size text size of the x labs, default 14
#' @param x.lab.angle text angle of the x labs, default 0
#' @param y.lab.size text size of the y labs, default 14
#' @param y.lab.angle text angle of the y labs, default 0
#' @param x.title.size text size of the x lab title, default 18
#' @param y.title.size text size of the y lab title, default 18
#' @param title.size text size of the plot title, default 20
#' @param col.limits limit number of the color bar, default NULL, if given, a vector consists of two numbers, the fisrt for min , the second for max
#' @param col.breaks break numbers of the color bar, if given, a vector consists of numbers, notes the numbers in the limits
#' @param col.labels labs of the break numbers , be consistent with the col.breaks
#' @param size.limits limit number of the size bar, default NULL, if given, a vector consists of two numbers, the fisrt for min , the second for max
#' @param size.breaks break numbers of the size bar, if given, a vector consists of numbers, notes the numbers in the limits
#' @param size.labels labs of the break numbers , be consistent with the size.breaks
#'
#' @return a ggplot2 object of matchstick plot
#' @export
#'
#' @examples my_matchstick_plot(df = GOdatframe, top = 20, y.decreasing = T,
#' x = 'Description', y = 'Count', size = 'Count', fill_col = 'pvalue',
#' col.breaks = c(3,4,5) , col.labels = c('low', '', 'high'),size.limits = c(20,40), size.breaks = c(20,30,40))

my_matchstick_plot <- function(df,  top=20, y.decreasing = T, logPV10 = T,
                               x='Description', y="count", size="count", fill_col="pvalue",
                               fill_col_pal = c("#BDD8E8", "#134B6C"), stick_col = "#FAAC90", stick_width=2,
                               title =NULL, xlab = NULL, ylab = "Gene counts",
                               x.lab.size=14, x.lab.angle=0, y.lab.size =14, y.lab.angle=0, x.title.size=18, y.title.size=18, title.size=20,
                               col.limits=NULL, col.breaks, col.labels,
                               size.limits=NULL, size.breaks, size.labels){

    ## plot data
    plot_df = data.frame(x_value = df[[x]],
                         y_value = df[[y]],
                         size_value =  df[[size]],
                         fill_col_value = df[[fill_col]])


    if(logPV10 == T){
        plot_df = plot_df %>% as.data.frame() %>% mutate(fill_col_value = -log10(fill_col_value))
        color.title = '-log10(pvalue)'

    }else{
        color.title = fill_col
        warning('Do not need to calculate the -log10(Pvalue) ? \n')
    }

    # arranged by decreasing y value (count) and pvalue
    plot_df = plot_df %>% arrange(desc(y_value), desc(fill_col_value)) %>% head(top) %>% as.data.frame()

    if(y.decreasing == T){
        # ordered x names
        plot_df$x_value = factor(plot_df$x_value, levels = rev(plot_df$x_value))
    }else{
        plot_df$x_value = factor(plot_df$x_value, levels = plot_df$x_value)
    }




    # plotting
    p <- ggplot(plot_df, aes(x=x_value, y=y_value)) +
        geom_segment(aes(x = x_value, xend = x_value,
                         y = 0, yend = y_value),
                     linewidth = stick_width,
                     color = stick_col,
                     linetype="solid") +
        geom_point(aes(color = fill_col_value,
                       size = size_value)) +
        scale_color_continuous(low = fill_col_pal[1], high = fill_col_pal[2]) +
        labs(x = xlab, y = ylab, title = title, color=color.title, size = size) +
        coord_flip()

    # set break points for continuous color bar
    if(!missing(col.breaks)){
        # defualt break = labs
        if(missing(col.labels)){
            col.labels = col.breaks
        }

        p = p + scale_color_gradient(low = fill_col_pal[1], high = fill_col_pal[2],
                                     limits = col.limits,
                                     breaks = col.breaks,
                                     labels = col.labels)
    }

    # set break points for continuous size bar
    if(!missing(size.breaks)){
        # defualt break = labs
        if(missing(size.labels)){
            size.labels = size.breaks
        }
        p = p + scale_size(limits = size.limits,
                           breaks = size.breaks,
                           labels = size.labels)
    }

    # theme
    p = p + theme_classic() +
        theme(plot.title = element_text(size = title.size, hjust=0.5),
              axis.text.x = element_text(size= x.lab.size, angle = x.lab.angle, vjust = 1),
              axis.text.y = element_text(size= y.lab.size, angle = y.lab.angle),
              axis.title.x = element_text(size = x.title.size),
              axis.title.y = element_text(size = y.title.size))

    return(p)
}



